# Message

> We made a simple MD5 calculator as a network service.
> Find a bug and exploit it to get a shell.
> Download : http://pwnable.kr/bin/hash
> hint : this service shares the same machine with pwnable.kr web service
> Running at : nc pwnable.kr 9002

# Step 0 - What does hash do?
First the application generates a "hash" and sends it to the user to check if they're human. This hash must first be sent back to the server before the rest of the logic happens. 

The application then simply takes in base64 encoded data, decodes it and then returns a hash of that data.

# Step 1 - Find the bug.

The bug is actually pretty easy to discover, and even easier to trigger.

The `process_hash` creates a buffer of 128 bytes on the stack. This buffer will contain the output from decoding the base64 encoded data. It then passes this buffer into the function `Base64Decode`. However, `g_buff`, the buffer which will receive the base64 encoded data is 0x400 (1024) bytes in size. This wouldn't be such a problem, if the
user could also send in 0x400 bytes into the function `fgets`. Though base64 encoded data is 1/4 bigger than the raw data, this means that without any other bounds 
checking, the function `Base64Decode` will overwrite the stack of the function `process_hash`.

# Step 2 - Stack Canary

There a problem however. We don't get immediate control of `EAX` on return from `process_hash`. The reason is that we are blowing away a stack canary. 

This took me quite some time to figure out, as there wasn't an apparent leak. As it turns out there's a very unapparent leak.

The function `my_hash` appears to generate a bunch of random numbers, and mix them together. Well, one of the numbers it mixes into the "hash" is the stack canary.

The random numbers are generated by setting `srand` to the system time in seconds since epoch. and uses `rand` to generate 8 numbers, of which the first one (0 index) is thrown out.

This means that if we can accuratly predict the time of the server running on pwnable.kr, we can also generate the same random numbers (because they'll be deteministic as long as we know the seed).

By knowing the final value of the random numbers, and the way they're added and subtraced, we can simply subtract the value of the captcha value from this value of random
numbers to reveal the stack canary value.

> Note: This can be verified as the stack canary always ends (or begins, depending on how you look at it), with a 0x00. It's a null terminated canary, and that's how they work. So if our end result ends in 0x00, we have a good warm-fuzzy that we may have found our canary.

## System Time

The hint in the description was useful in realizing that you can hit the web server to get the Date/Time. With a little python magic, we can convert that date/time format to 
epoch time. If we are quick, then we can also force the md5 calculator to generate a seed based on the exact same time. This works as long as we weren't close to rolling over
a second digit. It's surprisingly accurate.

Now that we have the canary, we can bypass the stack protections and return to anywhere we want from our buffer overflow.

# Step 3 - Where to return?

There's a very obvious `system` call towards the end of the function. That would be a good place to call, but if we put the string `/bin/sh` in our base64 encoded data it would end up on the stack and we don't know the location of our stack, and therefore won't know the location of any string we are able to put on it. This means we'll have to get the string `/bin/sh` from somewhere else. 

Looking deeper, it becomes very difficult to figure out how we'll get `/bin/sh` into memory in a predictable location. Finally, I noticed that because the binary doesn't ever
move location (aslr), the global variable `g_buff` is always a predictable address. As mentioned above, it contains our base64 encoded data. Appending `/bin/sh` to the
beginning or the end didn't work as it appeared that the base64 encoded wasn't tollerant to non-base64 encoded data. Oh well.

But what if we rop'd into `fgets`, passing `g_buff` as our buffer. Then we could read in the string `/bin/sh` and then jump to system on return, knowing that `/bin/sh` will 
be the string now in `g_buff` (and it's null terminated too!).

We get stopped cold, when we realize that we need a pointer to `FILE * stdin`. Though this pointer lives inside of our binary, the compiler actually keeps a pointer-to-a-pointer
to reference it where it actually lives which is inside libc. This pointer is populated at start, and the one we can predict (inside our program) won't work. We'd have to
dereference the predicatable addreess somehow in order for it to work.

But there's hope! The `process_hash` function does all this dirty work for us! All we need to do is call `process_hash` again, and this time, not provide base64 encoded data,
but provide the string `/bin/sh`. In this situation, we don't care if it gets decoded, in fact we don't want it to.

This gives us `/bin/sh` in a predictable location. As `process_hash` won't have its stack overwritten again we don't have to worry about the stack canary either. Finally,
all we need to do is to add the `system` call to our rop chain and we are finished.

See the `md5_sploit.py` script for the details

# Flag
Canary, Stack guard, Stack protector.. what is the correct expression?





